// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.4.4
// Machine:  TOMOYO
// DateTime: 2011-03-23 15:53:22
// UserName: Hundben
// Input file <CSPGF.trees.y - 2011-03-23 15:53:10>

// options: lines gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;

namespace CSPGF.Trees
{
    public enum Tokens
    {
        error = 1, EOF = 2, SYMB_0 = 3, SYMB_1 = 4, SYMB_2 = 5, SYMB_3 = 6,
        SYMB_4 = 7, SYMB_5 = 8, STRING_ = 9, INTEGER_ = 10, DOUBLE_ = 11, IDENT_ = 12
    };

    public struct ValueType
#line 35 "CSPGF.trees.y"
    {
#line 36 "CSPGF.trees.y"
        public int int_;
#line 37 "CSPGF.trees.y"
        public char char_;
#line 38 "CSPGF.trees.y"
        public double double_;
#line 39 "CSPGF.trees.y"
        public string string_;
#line 40 "CSPGF.trees.y"
        public CSPGF.Trees.Absyn.Tree tree_;
#line 41 "CSPGF.trees.y"
        public CSPGF.Trees.Absyn.Lit lit_;
#line 42 "CSPGF.trees.y"
    }
    // Abstract base class for GPLEX scanners
    public abstract class ScanBase : AbstractScanner<ValueType, LexLocation>
    {
        private LexLocation __yylloc = new LexLocation();
        public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
        protected virtual bool yywrap() { return true; }
    }

    public class Parser : ShiftReduceParser<ValueType, LexLocation>
    {
        internal Parser(Scanner lex)
            : base(lex)
        {
            // Whatever other initialization actions the parser needs 
        }
        // Verbatim content from CSPGF.trees.y - 2011-03-23 15:53:10
#line 5 "CSPGF.trees.y"

#line 6 "CSPGF.trees.y"
        CSPGF.Trees.Absyn.Tree YY_RESULT_Tree_ = null;
#line 7 "CSPGF.trees.y"
        public CSPGF.Trees.Absyn.Tree ParseTree()
#line 8 "CSPGF.trees.y"
        {
#line 9 "CSPGF.trees.y"
            if (this.Parse())
#line 10 "CSPGF.trees.y"
 {
#line 11 "CSPGF.trees.y"
                return YY_RESULT_Tree_;
#line 12 "CSPGF.trees.y"
            }
#line 13 "CSPGF.trees.y"
            else
#line 14 "CSPGF.trees.y"
 {
#line 15 "CSPGF.trees.y"
                throw new Exception("Could not parse input stream!");
#line 16 "CSPGF.trees.y"
            }
#line 17 "CSPGF.trees.y"
        }
#line 18 "CSPGF.trees.y"

#line 19 "CSPGF.trees.y"
        CSPGF.Trees.Absyn.Lit YY_RESULT_Lit_ = null;
#line 20 "CSPGF.trees.y"
        public CSPGF.Trees.Absyn.Lit ParseLit()
#line 21 "CSPGF.trees.y"
        {
#line 22 "CSPGF.trees.y"
            if (this.Parse())
#line 23 "CSPGF.trees.y"
 {
#line 24 "CSPGF.trees.y"
                return YY_RESULT_Lit_;
#line 25 "CSPGF.trees.y"
            }
#line 26 "CSPGF.trees.y"
            else
#line 27 "CSPGF.trees.y"
 {
#line 28 "CSPGF.trees.y"
                throw new Exception("Could not parse input stream!");
#line 29 "CSPGF.trees.y"
            }
#line 30 "CSPGF.trees.y"
        }
#line 31 "CSPGF.trees.y"

        // End verbatim content from CSPGF.trees.y - 2011-03-23 15:53:10

#pragma warning disable 649
        private static Dictionary<int, string> aliasses;
#pragma warning restore 649
        private static Rule[] rules = new Rule[11];
        private static State[] states = new State[20];
        private static string[] nonTerms = new string[] {
      "Tree", "Lit", "$accept", };

        static Parser()
        {
            states[0] = new State(new int[] { 3, 3, 5, 7, 6, 9, 10, 14, 11, 15, 9, 16, 8, 17, 12, 19 }, new int[] { -1, 1, -2, 13 });
            states[1] = new State(new int[] { 2, 2 });
            states[2] = new State(-1);
            states[3] = new State(new int[] { 12, 4 });
            states[4] = new State(new int[] { 4, 5 });
            states[5] = new State(new int[] { 3, 3, 5, 7, 6, 9, 10, 14, 11, 15, 9, 16, 8, 17, 12, 19 }, new int[] { -1, 6, -2, 13 });
            states[6] = new State(-2);
            states[7] = new State(new int[] { 10, 8 });
            states[8] = new State(-3);
            states[9] = new State(new int[] { 3, 3, 5, 7, 6, 9, 10, 14, 11, 15, 9, 16, 8, 17, 12, 19 }, new int[] { -1, 10, -2, 13 });
            states[10] = new State(new int[] { 3, 3, 5, 7, 6, 9, 10, 14, 11, 15, 9, 16, 8, 17, 12, 19 }, new int[] { -1, 11, -2, 13 });
            states[11] = new State(new int[] { 7, 12 });
            states[12] = new State(-4);
            states[13] = new State(-5);
            states[14] = new State(-8);
            states[15] = new State(-9);
            states[16] = new State(-10);
            states[17] = new State(new int[] { 10, 18 });
            states[18] = new State(-6);
            states[19] = new State(-7);

            for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

            rules[1] = new Rule(-3, new int[] { -1, 2 });
            rules[2] = new Rule(-1, new int[] { 3, 12, 4, -1 });
            rules[3] = new Rule(-1, new int[] { 5, 10 });
            rules[4] = new Rule(-1, new int[] { 6, -1, -1, 7 });
            rules[5] = new Rule(-1, new int[] { -2 });
            rules[6] = new Rule(-1, new int[] { 8, 10 });
            rules[7] = new Rule(-1, new int[] { 12 });
            rules[8] = new Rule(-2, new int[] { 10 });
            rules[9] = new Rule(-2, new int[] { 11 });
            rules[10] = new Rule(-2, new int[] { 9 });
        }

        protected override void Initialize()
        {
            this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
            this.InitStates(states);
            this.InitRules(rules);
            this.InitNonTerminals(nonTerms);
        }

        protected override void DoAction(int action)
        {
            switch (action) {
                case 2: // Tree -> SYMB_0, IDENT_, SYMB_1, Tree
#line 60 "CSPGF.trees.y"
 { CurrentSemanticValue.tree_ = new CSPGF.Trees.Absyn.Lambda(ValueStack[ValueStack.Depth - 3].string_, ValueStack[ValueStack.Depth - 1].tree_); YY_RESULT_Tree_ = CurrentSemanticValue.tree_; }
 break;
                case 3: // Tree -> SYMB_2, INTEGER_
#line 61 "CSPGF.trees.y"
 { CurrentSemanticValue.tree_ = new CSPGF.Trees.Absyn.Variable(ValueStack[ValueStack.Depth - 1].int_); YY_RESULT_Tree_ = CurrentSemanticValue.tree_; }
 break;
                case 4: // Tree -> SYMB_3, Tree, Tree, SYMB_4
#line 62 "CSPGF.trees.y"
 { CurrentSemanticValue.tree_ = new CSPGF.Trees.Absyn.Application(ValueStack[ValueStack.Depth - 3].tree_, ValueStack[ValueStack.Depth - 2].tree_); YY_RESULT_Tree_ = CurrentSemanticValue.tree_; }
 break;
                case 5: // Tree -> Lit
#line 63 "CSPGF.trees.y"
 { CurrentSemanticValue.tree_ = new CSPGF.Trees.Absyn.Literal(ValueStack[ValueStack.Depth - 1].lit_); YY_RESULT_Tree_ = CurrentSemanticValue.tree_; }
 break;
                case 6: // Tree -> SYMB_5, INTEGER_
#line 64 "CSPGF.trees.y"
 { CurrentSemanticValue.tree_ = new CSPGF.Trees.Absyn.MetaVariable(ValueStack[ValueStack.Depth - 1].int_); YY_RESULT_Tree_ = CurrentSemanticValue.tree_; }
 break;
                case 7: // Tree -> IDENT_
#line 65 "CSPGF.trees.y"
 { CurrentSemanticValue.tree_ = new CSPGF.Trees.Absyn.Function(ValueStack[ValueStack.Depth - 1].string_); YY_RESULT_Tree_ = CurrentSemanticValue.tree_; }
 break;
                case 8: // Lit -> INTEGER_
#line 67 "CSPGF.trees.y"
 { CurrentSemanticValue.lit_ = new CSPGF.Trees.Absyn.IntLiteral(ValueStack[ValueStack.Depth - 1].int_); YY_RESULT_Lit_ = CurrentSemanticValue.lit_; }
 break;
                case 9: // Lit -> DOUBLE_
#line 68 "CSPGF.trees.y"
 { CurrentSemanticValue.lit_ = new CSPGF.Trees.Absyn.FloatLiteral(ValueStack[ValueStack.Depth - 1].double_); YY_RESULT_Lit_ = CurrentSemanticValue.lit_; }
 break;
                case 10: // Lit -> STRING_
#line 69 "CSPGF.trees.y"
 { CurrentSemanticValue.lit_ = new CSPGF.Trees.Absyn.StringLiteral(ValueStack[ValueStack.Depth - 1].string_); YY_RESULT_Lit_ = CurrentSemanticValue.lit_; }
 break;
            }
        }

        protected override string TerminalToString(int terminal)
        {
            if (aliasses != null && aliasses.ContainsKey(terminal))
                return aliasses[terminal];
            else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
                return ((Tokens)terminal).ToString();
            else
                return CharToString((char)terminal);
        }

    }
}
